# javascript-lotto-precourse
> 콘솔 기반 로또 발매 및 당첨 결과 계산 프로그램  
> 사용자는 로또를 구입하고, 당첨 번호를 입력하여 결과와 수익률을 확인할 수 있습니다.

### 💡 왜 구현을 해야 하는가
시작 전, 로또는 그냥 숫자 뽑기 앱일까?라고 고민했음. 그렇다면 굳이 구조를 나누고 테스트를 깔아야 할 이유가 있을까?

로또 프로그램은 겉보기엔 단순하지만, 실제로는 입력 → 검증 → 로또 생성 → 당첨 판정 → 통계 → 출력으로 이어지는 단계마다 서로 다른 책임이 존재함. 이걸 한 파일에 몰아두면 기능 추가/수정 때 사이드 이펙트가 커지고, 테스트도 어려워짐. 따라서 이번 과제에서는 다음 세 가지를 목표로 삼음

1. 계층 분리- view(입출력)와 domain(규칙/모델), service(흐름 오케스트레이션), util(검증), constants(상수)로 역할을 나눔.

2. 상수의 일원화- 가격/범위/등수·상금/에러 문구를 LottoConstants로 모아 하드코딩을 제거하고 변경 비용을 낮춤.

3. 테스트 가능성 확보- Lotto, WinCondition, Statistics 같은 도메인 로직을 I/O와 분리해 단위 테스트만으로도 신뢰성을 높임.

---

### 기능 명세서 

- [x] **로또 구입**
  - [x] 구입 금액 입력받기 (1,000원 단위)
  - [x] 구입 금액 ÷ 1,000원 = 발행할 로또 개수
  - [x] 각 로또는 1~45 사이의 중복 없는 6개 숫자로 구성
  - [x] 발행된 로또 번호 오름차순 정렬하여 출력

- [x] **당첨 번호 입력**
  - [x] 당첨 번호 6개 입력받기 (쉼표로 구분)
  - [x] 보너스 번호 1개 입력받기
  - [x] 입력된 당첨 번호와 보너스 번호 출력

- [x] **당첨 판정**
  - [x] 로또 번호와 당첨 번호 일치 개수 계산
  - [x] 보너스 번호 일치 여부 확인
  - [x] 등수 판정 (1등: 6개 일치, 2등: 5개+보너스, 3등: 5개, 4등: 4개, 5등: 3개)

- [x] **통계 출력**
  - [x] 등수별 당첨 개수 집계
  - [x] 총 수익금 계산
  - [x] 수익률 계산 (소수점 둘째 자리에서 반올림)

### 예외 케이스

- [x] **구입 금액 예외**
  - [x] 구입 금액이 1,000원 단위가 아닌 경우
  - [x] `[ERROR] 구입 금액은 1000원 단위여야 합니다.`
  - [x] 에러 메시지 출력 후 재입력 요청

- [x] **당첨 번호 예외**
  - [x] 당첨 번호가 6개가 아닌 경우
  - [x] `[ERROR] 당첨 번호는 6개여야 합니다.`
  - [x] 당첨 번호가 1~45 범위를 벗어나는 경우
  - [x] `[ERROR] 로또 번호는 1부터 45 사이의 숫자여야 합니다.`
  - [x] 당첨 번호에 중복이 있는 경우
  - [x] `[ERROR] 로또 번호는 중복될 수 없습니다.`
  - [x] 에러 메시지 출력 후 재입력 요청

- [x] **보너스 번호 예외**
  - [x] 보너스 번호가 1~45 범위를 벗어나는 경우
  - [x] `[ERROR] 로또 번호는 1부터 45 사이의 숫자여야 합니다.`
  - [x] 보너스 번호가 당첨 번호와 중복되는 경우
  - [x] `[ERROR] 보너스 번호가 당첨 번호와 중복될 수 없습니다.`
  - [x] 에러 메시지 출력 후 재입력 요청

---

### 프로젝트 구조 설계 의도 

이번 로또 미션에서는 처음으로 프로젝트의  레이어드 구조를 직접 설계해 보았음.
그동안은 주어진 폴더 안에서 코드를 작성하는 경우가 많았지만, 이번에는 어떤 책임을 어디에 두는 게 맞을까?를 처음부터 고민하면서 구조를 만들어 나갔음.

프로그램의 핵심 흐름은 입력 → 검증 → 로또 생성 → 당첨 판정 → 통계 계산 → 출력으로 이어지며, 각 단계마다 성격이 다른 책임을 갖고 있음. 이 과정을 체계적으로 관리하기 위해 계층형 아키텍처 방식을 적용함.

#### 파일 구조 
```
javascript-lotto-precourse
├── README.md
├── index.js
└── src
    ├── App.js
    │
    ├── constants
    │   └── LottoConstants.js
    │
    ├── controller
    │   └── LottoController.js
    │
    ├── domain
    │   ├── Lotto.js
    │   ├── Statistics.js
    │   └── WinCondition.js
    │
    ├── service
    │   ├── GameService.js
    │   └── LottoGenerator.js
    │
    ├── util
    │   └── Validator.js
    │
    └── view
        ├── InputView.js
        └── OutputView.js

```
--- 
### 💭 코드 개선 고민 1 🤔

#### 로또 번호 생성 로직을 어디에 둬야 할까?

초기에는 Lotto 클래스 안에서 번호를 랜덤으로 생성하도록 작성했음.
하지만 생각해보니, 로또 번호 생성은 로또 객체의 책임이라기보다 로또를 만드는 행위의 책임에 더 가깝다는 점을 깨달았음.
Lotto는 생성된 번호를 관리하고, 유효성을 보장하는 역할에 집중해야 하고, 랜덤 생성 로직까지 포함하면 단일 책임 원칙(SRP)을 위반하게 됨.

그래서 번호 생성 책임을 LottoGenerator로 분리함. LottoGenerator는 1~45 범위에서 중복 없는 6개의 숫자를 생성하는 역할만 담당하고,
Lotto는 단지 전달받은 숫자가 유효한지 검증하는 순수 도메인 객체로 남김.

---

### 💭 코드 개선 고민 2 🤔

#### 로직은 같지만, 숫자만 다른 상수들을 어떻게 관리해야 할까?

개발 초반에는 각 파일마다 상금, 일치 개수, 에러 메시지를 직접 정의했음.
예를 들어 Statistics, Validator, WinCondition 안에
비슷한 숫자 상수들이 중복 선언되면서, 수정 시 전체 파일을 일일이 찾아 바꿔야 했음.

이 구조는 단기적으로는 빠르지만, 장기적으로 유지보수에 큰 리스크가 있음.
한 곳에서만 수정해도 전체 로직이 일관되게 유지되도록 하려면 “상수를 모아 관리하는 단일 진실의 원천(Single Source of Truth)”이 필요하다고 판단함. 그래서 LottoConstants.js 파일을 새로 만들어

로또 가격, 번호 범위, 등수별 상금, 일치 개수, 에러 메시지 등을 전부 이곳에서 관리하도록 구조를 변경함.

### 개발을 마무리하며

처음으로 레이어드 구조를 직접 설계해 보았음. 굳이 이렇게까지 구조를 나눠야 하나 싶었고, 작은 프로그램이라면 단일 파일로도 충분하지 않을까? 하는 의문이 들었음.

하지만 실제로 코드를 작성해 보니, 입력, 검증, 로직, 출력의 책임을 분리한 구조가 유지보수성을 크게 높여준다는 걸 체감했음.
예를 들어 도메인 로직을 수정하더라도 입출력 레이어를 건드릴 필요가 없었고,
테스트 시에도 콘솔을 직접 실행하지 않아도 핵심 로직만 검증할 수 있었음.레이어드 구조가 단순한 형식이 아니라 코드를 안정적이고 확장 가능하게 만드는 사고 방식임을 배웠음.